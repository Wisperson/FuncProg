import random


def sum_of_even_squares_def(numbers):
    return sum(x ** 2 for x in numbers if x % 2 == 0)


def correct_sum_of_even(numbers):
    #return sum(x ** 2 for x in filter(lambda x: x if x % 2 == 0 else 0, numbers))
    return sum(list(map(lambda x: x ** 2, list(filter(lambda x: x % 2 == 0, numbers)))))

sum_of_even_squares = lambda numbers: sum(x ** 2 for x in numbers if x % 2 == 0)


random_numbers = [random.randint(0, 100) for _ in range(20)]
print("Список случайных чисел:", random_numbers)
print("Сумма квадратов четных чисел:", sum_of_even_squares(random_numbers))
print("Сумма квадратов четных чисел:", correct_sum_of_even(random_numbers))
print("Сумма квадратов четных чисел:", sum_of_even_squares_def(random_numbers))

'''
1. функциональный подход отличается от императивного в нескольких аспектах:
функциональный подход ЗАПРЕЩАЕТ изменение исходных данных
функциональный подход не ответсвенен за изменение данных, лишь их обработку и
создание новых данных на основе исходных
функциональный подход старается избегать побочных эффектов выполнения кода

2. Преимущества функционального подхода:
в связи с сохранением целостности изначальных данных и чистой работы кода
без неожиданных эффектов, функциональный подход может похвастаться масшабируемостью,
абстракцией и надежностью, также лучше подходит для параллельных задач

3. Чистая функция - зависит только от входных данных, её вывод не зависит от среды,
и всегда одинаков при одинаковых входных данных. изменять входные данные чистая функция
тоже НЕ МОЖЕТ
Пример: list_sum = lambda numbers: sum(x for x in numbers)

4. Лямбда-функции - анонимные функции. отличаются краткостью и компактностью
написания. инициализируются ключевым словом lambda

5. map - принимает функцию и итерируемый объект (массив, лист и т.п.), применяет
функцию к каждому элементу объекта, возвращает новый итерируемый объект
filter - принимает логическую функцию (её возврат должен быть true либо false)
и итерируемый объект. возвращает новый итерируемый объект, состоящий только из тех элементов
обработка которых функцией вернула результат true
reduce - принимает функцию, которая должна принимать 2 параметра, и итерируемый объект
возвращает удинственное значение, полученное в резульате попарного прохода функцией
по итерируемому объекту

6. рекурсия - вызов функцией самой себя. Пример использования - вычисление факториала
числа. Стандартное ограничение на глубину рекурсии в python - 3000 вызовов

7. единожды использовать источник данных, хранить результаты всех вызовов в 1 общедоступном
объекте. оптимизация кода с целью сокращения кол-ва вызовов и ресурсозатрат на каждый отдельный вызов

8. в функциональном подходе функции не изменяют изначальные данные, чисты от побочных эффектов,
компактны и эффективны

9. изменяемые объекты - массивы, листы и т.п. способны изменяться без объявления новых себя
list.append(x)
неизменяемые объекты - числа, строки, кортежи. полноценного изменения не происходит, вместо этого
происходит переопределение переменной.
x = x + 1

10. функциональное программирование создано быть высокоэффективным: исходные данные не меняются в
процессе выполнения программы. также, в функциональном подходе выше производительность (за счёт оптимизации)
'''
