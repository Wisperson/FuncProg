import time


def timeit(func):
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        func_time = end_time - start_time
        print("Время выполнения функции '{0}': {1:.20f} секунд".format(func.__name__, func_time))
        return result
    return wrapper


@timeit
def timed_gcd(num1, num2):
    def gcd(a, b):
        if b == 0:
            return a
        else:
            return gcd(b, a % b)

    return gcd(num1, num2)


input1 = 572
input2 = 13
print("Наибольший общий делитель чисел", input1, "и", input2, ":", timed_gcd(input1, input2))


'''
Рекурсия - это процесс, в котором функция вызывает саму себя внутри своего определения. В контексте программирования, рекурсия позволяет решать задачи путем разбиения их на более простые подзадачи, которые решаются аналогичным способом. Каждый вызов функции ведет к новому экземпляру этой функции, пока не будет достигнуто базовое условие завершения.

Основные компоненты рекурсивной функции:

Базовый случай: это условие, при котором рекурсия завершается и функция больше не вызывает саму себя.
Рекурсивный случай: это часть функции, в которой происходит вызов функции самой себя с измененными параметрами.
Преимущества использования рекурсии:

Код становится более читаемым и понятным, особенно для задач, которые естественным образом разбиваются на подзадачи.
Некоторые задачи проще решать с использованием рекурсии, чем с помощью итерации.
Рекурсия может быть эффективным способом решения задач, связанных с деревьями и графами.
Недостатки использования рекурсии:

Переполнение стека вызовов при большой глубине рекурсии.
Расход памяти из-за сохранения промежуточных результатов каждого вызова функции.
Пример задачи, для которой рекурсия является наилучшим решением, - вычисление факториала числа или чисел Фибоначчи.

Для избежания переполнения стека вызовов в рекурсии можно использовать хвостовую рекурсию или мемоизацию.

Хвостовая рекурсия - это специальный случай рекурсии, при котором вызов рекурсивной функции является последней операцией перед возвратом результата. Это важно, потому что компилятор может оптимизировать хвостовую рекурсию, превращая ее в итеративный процесс, что уменьшает расход памяти и предотвращает переполнение стека вызовов.

Для реализации мемоизации в рекурсивной функции можно использовать кэширование результатов предыдущих вызовов, чтобы избежать повторных вычислений.

Рекурсивный подход к решению задач использует вызов функции самой себя, в то время как итеративный подход использует циклы. Оба подхода имеют свои преимущества и недостатки, но во многих случаях можно использовать как рекурсию, так и итерацию.

Ошибки, которые могут возникнуть при написании рекурсивных функций, включают в себя бесконечную рекурсию из-за отсутствия или неправильного базового случая, а также переполнение стека вызовов. Их можно избежать, убедившись, что базовый случай явно определен и что рекурсивный случай сходится к базовому случаю.

Рекурсия может быть использована для обхода структур данных, таких как деревья и графы, с помощью обхода в глубину или в ширину. Например, обход дерева для поиска элемента или выполнения определенной операции для каждого элемента дерева может быть реализован с использованием рекурсии.
'''